diff --git a/u-boot-2014.04/board/samsung/smdkv210/smdkv210.c b/u-boot-2014.04/board/samsung/smdkv210/smdkv210.c
index 7863b72..e88680a 100755
--- a/u-boot-2014.04/board/samsung/smdkv210/smdkv210.c
+++ b/u-boot-2014.04/board/samsung/smdkv210/smdkv210.c
@@ -12,6 +12,7 @@
 #include <asm/arch/gpio.h>
 #include <asm/arch/clock.h>		/* add by zwf */
 #include <asm/arch/dmc.h>		/* add by zwf */
+#include <asm/arch/nand_reg.h>	/* add by zwf */
 #include <netdev.h>
 
 #ifndef CONFIG_SPL_BUILD	/* add by zwf */
@@ -141,7 +142,7 @@ void clock_init(void)
 	*/
 	writel((1 << 0) | (1 << 4) | (1 << 8) | (1 << 12), &clock->src0);
 
-	/* 4.设置其他模块的时钟源 */
+	/* 5.设置其他模块的时钟源 */
 
 	/* 6.设置系统时钟分频值 */
 	val = 	(0 << 0)  |	/* APLL_RATIO = 0, freq(ARMCLK) = MOUT_MSYS / (APLL_RATIO + 1) = 1000MHz */
@@ -244,22 +245,70 @@ void copy_bl2_to_ram(void)
 ** sb:  起始块
 ** bs:  块大小
 ** dst: 目的地
-** i: 	是否初始化
+** i: 是否初始化
 */
-#define CopySDMMCtoMem(ch, sb, bs, dst, i) \
-	(((unsigned char(*)(int, unsigned int, unsigned short, unsigned int*, unsigned char))\
-	(*((unsigned int *)0xD0037F98)))(ch, sb, bs, dst, i))
-
-	unsigned int V210_SDMMC_BASE = *(volatile unsigned int *)(0xD0037488);	// V210_SDMMC_BASE
-	unsigned char ch = 0;
 
-	/* 参考S5PV210手册7.9.1 SD/MMC REGISTER MAP */
-	if (V210_SDMMC_BASE == 0xEB000000)		// 通道0
-		ch = 0;
-	else if (V210_SDMMC_BASE == 0xEB200000)	// 通道2
-		ch = 2;
-
-	CopySDMMCtoMem(ch, 32, 500, (unsigned int *)CONFIG_SYS_SDRAM_BASE, 0);
+#define CopySDMMCtoMem(ch, sb, bs, dst, i) \
+	(((u8(*)(int, u32, unsigned short, u32*, u8))\
+	(*((u32 *)0xD0037F98)))(ch, sb, bs, dst, i))
+
+#define MP0_1CON  (*(volatile u32 *)0xE02002E0)
+#define	MP0_3CON  (*(volatile u32 *)0xE0200320)
+#define	MP0_6CON  (*(volatile u32 *)0xE0200380)
+
+#define NF8_ReadPage_Adv(a,b,c) (((int(*)(u32, u32, u8*))(*((u32 *)0xD0037F90)))(a,b,c))
+
+	u32 bl2Size = 250 * 1024;	// 250K
+
+	u32 OM = *(volatile u32 *)(0xE0000004);	// OM Register
+	OM &= 0x1F;					// 取低5位
+
+	if (OM == 0x2)				// NAND 2 KB, 5cycle 8-bit ECC
+	{
+		u32 cfg = 0;
+		struct s5pv210_nand *nand_reg = (struct s5pv210_nand *)(struct s5pv210_nand *)samsung_get_base_nand();
+
+		/* initialize hardware */
+		/* HCLK_PSYS=133MHz(7.5ns) */
+		cfg =	(0x1 << 23) |	/* Disable 1-bit and 4-bit ECC */
+				/* 下面3个时间参数稍微比计算出的值大些（我这里依次加1），否则读写不稳定 */
+				(0x3 << 12) |	/* 7.5ns * 2 > 12ns tALS tCLS */
+				(0x2 << 8) | 	/* (1+1) * 7.5ns > 12ns (tWP) */
+				(0x1 << 4) | 	/* (0+1) * 7.5 > 5ns (tCLH/tALH) */
+				(0x0 << 3) | 	/* SLC NAND Flash */
+				(0x0 << 2) |	/* 2KBytes/Page */
+				(0x1 << 1);		/* 5 address cycle */
+
+		writel(cfg, &nand_reg->nfconf);
+
+		writel((0x1 << 1) | (0x1 << 0), &nand_reg->nfcont);
+		/* Disable chip select and Enable NAND Flash Controller */
+
+		/* Config GPIO */
+		MP0_1CON &= ~(0xFFFF << 8);
+		MP0_1CON |= (0x3333 << 8);
+		MP0_3CON = 0x22222222;
+		MP0_6CON = 0x22222222;
+
+		int i = 0;
+		int pages = bl2Size / 2048;			// 多少页
+		int offset = 0x4000 / 2048;			// u-boot.bin在NAND中的偏移地址(页地址)
+		u8 *p = (u8 *)CONFIG_SYS_SDRAM_BASE;
+		for (; i < pages; i++, p += 2048, offset += 1)
+			NF8_ReadPage_Adv(offset / 64, offset % 64, p);
+	}
+	else if (OM == 0xC)		// SD/MMC
+	{
+		u32 V210_SDMMC_BASE = *(volatile u32 *)(0xD0037488);	// V210_SDMMC_BASE
+		u8 ch = 0;
+
+		/* 参考S5PV210手册7.9.1 SD/MMC REGISTER MAP */
+		if (V210_SDMMC_BASE == 0xEB000000)			// 通道0
+			ch = 0;
+		else if (V210_SDMMC_BASE == 0xEB200000)		// 通道2
+			ch = 2;
+		CopySDMMCtoMem(ch, 32, bl2Size / 512, (u32 *)CONFIG_SYS_SDRAM_BASE, 0);
+	}
 }
 
 #endif	/* CONFIG_SPL_BUILD (add by zwf) */
diff --git a/u-boot-2014.04/drivers/mtd/nand/s3c2410_nand.c b/u-boot-2014.04/drivers/mtd/nand/s3c2410_nand.c
old mode 100644
new mode 100755
index db87d07..a2e0a02
--- a/u-boot-2014.04/drivers/mtd/nand/s3c2410_nand.c
+++ b/u-boot-2014.04/drivers/mtd/nand/s3c2410_nand.c
@@ -74,7 +74,7 @@ static int s3c2410_dev_ready(struct mtd_info *mtd)
 	return readl(&nand->nfstat) & 0x01;
 }
 
-#ifdef CONFIG_S3C2410_NAND_HWECC
+#ifdef CONFIG_S5PV210_NAND_HWECC
 void s3c2410_nand_enable_hwecc(struct mtd_info *mtd, int mode)
 {
 	struct s3c2410_nand *nand = s3c2410_get_base_nand();
@@ -153,7 +153,7 @@ int board_nand_init(struct nand_chip *nand)
 
 	nand->dev_ready = s3c2410_dev_ready;
 
-#ifdef CONFIG_S3C2410_NAND_HWECC
+#ifdef CONFIG_S5PV210_NAND_HWECC
 	nand->ecc.hwctl = s3c2410_nand_enable_hwecc;
 	nand->ecc.calculate = s3c2410_nand_calculate_ecc;
 	nand->ecc.correct = s3c2410_nand_correct_data;
diff --git a/u-boot-2014.04/drivers/mtd/nand/s5pv210_nand.c b/u-boot-2014.04/drivers/mtd/nand/s5pv210_nand.c
index 63ed801..c308eb8 100755
--- a/u-boot-2014.04/drivers/mtd/nand/s5pv210_nand.c
+++ b/u-boot-2014.04/drivers/mtd/nand/s5pv210_nand.c
@@ -51,27 +51,89 @@ static int s5pv210_dev_ready(struct mtd_info *mtd)
 	return readl(&nand->nfstat) & 0x01;
 }
 
-#ifdef CONFIG_S3C2410_NAND_HWECC
+#ifdef CONFIG_S5PV210_NAND_HWECC
 void s5pv210_nand_enable_hwecc(struct mtd_info *mtd, int mode)
 {
 	struct s5pv210_nand *nand = (struct s5pv210_nand *)samsung_get_base_nand();
 	debug("s5pv210_nand_enable_hwecc(%p, %d)\n", mtd, mode);
-	writel(readl(&nand->nfconf) | S3C2410_NFCONF_INITECC, &nand->nfconf);
+
+	writel(readl(&nand->nfconf) | (0x3 << 23), &nand->nfconf);
+
+	if (mode == NAND_ECC_READ)
+	{
+	}
+	else if (mode == NAND_ECC_WRITE)
+	{
+		/* set 8/12/16bit Ecc direction to Encoding */
+		writel(readl(&nand->nfecccont) | (0x1 << 16), &nand->nfecccont);
+		/* clear 8/12/16bit ecc encode done */
+		writel(readl(&nand->nfeccstat) | (0x1 << 25), &nand->nfeccstat);
+	}
+
+	/* Initialize main area ECC decoder/encoder */
+	writel(readl(&nand->nfcont) | (0x1 << 5), &nand->nfcont);
+
+	/* The ECC message size(For 512-byte message, you should set 511)
+	* 8-bit ECC/512B */
+	writel((511 << 16) | 0x3, &nand->nfeccconf);
+
+	writel(readl(&nand->nfstat) | (0x1 << 4) | (0x1 << 5), &nand->nfstat);
+
+	/* Initialize main area ECC decoder/ encoder */
+	writel(readl(&nand->nfecccont) | (0x1 << 2), &nand->nfecccont);
+
+	/* Unlock Main area ECC   */
+	writel(readl(&nand->nfcont) & ~(0x1 << 7), &nand->nfcont);
 }
 
+/* modied by zwf */
 static int s5pv210_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
 				      u_char *ecc_code)
 {
 	struct s5pv210_nand *nand = (struct s5pv210_nand *)samsung_get_base_nand();
-	ecc_code[0] = readb(&nand->nfecc);
-	ecc_code[1] = readb(&nand->nfecc + 1);
-	ecc_code[2] = readb(&nand->nfecc + 2);
-	debug("s5pv210_nand_calculate_hwecc(%p,): 0x%02x 0x%02x 0x%02x\n",
-	       mtd , ecc_code[0], ecc_code[1], ecc_code[2]);
+	u32 nfeccprgecc0 = 0, nfeccprgecc1 = 0, nfeccprgecc2 = 0, nfeccprgecc3 = 0;
+
+	/* Lock Main area ECC */
+	writel(readl(&nand->nfcont) | (1 << 7), &nand->nfcont);
+
+	/* 读取13 Byte的Ecc Code */
+	nfeccprgecc0 = readl(&nand->nfeccprgecc0);
+	nfeccprgecc1 = readl(&nand->nfeccprgecc1);
+	nfeccprgecc2 = readl(&nand->nfeccprgecc2);
+	nfeccprgecc3 = readl(&nand->nfeccprgecc3);
+
+	ecc_code[0] = nfeccprgecc0 & 0xff;
+	ecc_code[1] = (nfeccprgecc0 >> 8) & 0xff;
+	ecc_code[2] = (nfeccprgecc0 >> 16) & 0xff;
+	ecc_code[3] = (nfeccprgecc0 >> 24) & 0xff;
+	ecc_code[4] = nfeccprgecc1 & 0xff;
+	ecc_code[5] = (nfeccprgecc1 >> 8) & 0xff;
+	ecc_code[6] = (nfeccprgecc1 >> 16) & 0xff;
+	ecc_code[7] = (nfeccprgecc1 >> 24) & 0xff;
+	ecc_code[8] = nfeccprgecc2 & 0xff;
+	ecc_code[9] = (nfeccprgecc2 >> 8) & 0xff;
+	ecc_code[10] = (nfeccprgecc2 >> 16) & 0xff;
+	ecc_code[11] = (nfeccprgecc2 >> 24) & 0xff;
+	ecc_code[12] = nfeccprgecc3 & 0xff;
+
+	debug("s5pv210_nand_calculate_hwecc(%p,):\n"
+		"0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n"
+		"0x%02x 0x%02x 0x%02x\n", mtd , ecc_code[0], ecc_code[1], ecc_code[2],
+		ecc_code[3], ecc_code[4], ecc_code[5], ecc_code[6], ecc_code[7],
+		ecc_code[8], ecc_code[9], ecc_code[10], ecc_code[11], ecc_code[12]);
 
 	return 0;
 }
 
+/* add by zwf */
+#define NF8_ReadPage_Adv(a,b,c) (((int(*)(u32, u32, u8*))(*((u32 *)0xD0037F90)))(a,b,c))
+static int s5pv210_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf, int oob_required, int page)
+{
+	/* TQ210使用的NAND FLASH一个块64页 */
+	return NF8_ReadPage_Adv(page / 64, page % 64, buf);
+}
+
 static int s5pv210_nand_correct_data(struct mtd_info *mtd, u_char *dat,
 				     u_char *read_ecc, u_char *calc_ecc)
 {
@@ -110,10 +172,26 @@ static void s5pv210_nand_select_chip(struct mtd_info *mtd, int ctl)
 	}
 }
 
+/* add by zwf */
+static struct nand_ecclayout nand_oob_64 = {
+	.eccbytes = 52,		/* 2048 / 512 * 13 */
+	.eccpos = {	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+				22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+				32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
+				42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
+				52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
+				62, 63},
+	/* 0和1用于保存坏块标记，12~63保存ecc，剩余2~11为free */
+	.oobfree = {
+			{.offset = 2,
+			.length = 10}
+		}
+};
+
 /* modied by zjh */
 int board_nand_init(struct nand_chip *nand)
 {
-	u32 cfg;
+	u32 cfg = 0;
 	struct s5pv210_nand *nand_reg = (struct s5pv210_nand *)(struct s5pv210_nand *)samsung_get_base_nand();
 
 	debug("board_nand_init()\n");
@@ -154,7 +232,7 @@ int board_nand_init(struct nand_chip *nand)
 
 	nand->dev_ready = s5pv210_dev_ready;
 
-#ifdef CONFIG_S3C2410_NAND_HWECC
+#ifdef CONFIG_S5PV210_NAND_HWECC
 	nand->ecc.hwctl = s5pv210_nand_enable_hwecc;
 	nand->ecc.calculate = s5pv210_nand_calculate_ecc;
 	nand->ecc.correct = s5pv210_nand_correct_data;
@@ -162,6 +240,9 @@ int board_nand_init(struct nand_chip *nand)
 	nand->ecc.size = CONFIG_SYS_NAND_ECCSIZE;
 	nand->ecc.bytes = CONFIG_SYS_NAND_ECCBYTES;
 	nand->ecc.strength = 1;
+	/* add by zwf */
+	nand->ecc.layout = &nand_oob_64;
+	nand->ecc.read_page = s5pv210_nand_read_page_hwecc;
 #else
 	nand->ecc.mode = NAND_ECC_SOFT;
 #endif
diff --git a/u-boot-2014.04/include/configs/smdkv210.h b/u-boot-2014.04/include/configs/smdkv210.h
index bdc44fe..053f9d0 100755
--- a/u-boot-2014.04/include/configs/smdkv210.h
+++ b/u-boot-2014.04/include/configs/smdkv210.h
@@ -88,6 +88,11 @@
 #define CONFIG_SYS_NAND_BASE 0xB0E00000
 /*add by zwf*/
 #define CONFIG_NAND_S5PV210
+/*add by zwf*/
+#define CONFIG_S5PV210_NAND_HWECC
+#define CONFIG_SYS_NAND_ECCSIZE		512
+#define CONFIG_SYS_NAND_ECCBYTES	13
+
 #define CONFIG_CMD_ELF
 #define CONFIG_CMD_FAT
 #define CONFIG_CMD_MTDPARTS
